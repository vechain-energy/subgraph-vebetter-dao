// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class Round extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Round entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Round must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Round", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Round | null {
    return changetype<Round | null>(store.get_in_block("Round", id));
  }

  static load(id: string): Round | null {
    return changetype<Round | null>(store.get("Round", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get voteStart(): BigInt {
    let value = this.get("voteStart");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voteStart(value: BigInt) {
    this.set("voteStart", Value.fromBigInt(value));
  }

  get voteEnd(): BigInt {
    let value = this.get("voteEnd");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voteEnd(value: BigInt) {
    this.set("voteEnd", Value.fromBigInt(value));
  }

  get apps(): Array<Bytes> {
    let value = this.get("apps");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytesArray();
    }
  }

  set apps(value: Array<Bytes>) {
    this.set("apps", Value.fromBytesArray(value));
  }

  get proposals(): ProposalLoader {
    return new ProposalLoader("Round", this.get("id")!.toString(), "proposals");
  }

  get allocations(): Array<string> {
    let value = this.get("allocations");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toStringArray();
    }
  }

  set allocations(value: Array<string>) {
    this.set("allocations", Value.fromStringArray(value));
  }

  get veDelegateAllocations(): Array<string> {
    let value = this.get("veDelegateAllocations");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toStringArray();
    }
  }

  set veDelegateAllocations(value: Array<string>) {
    this.set("veDelegateAllocations", Value.fromStringArray(value));
  }

  get statistic(): string {
    let value = this.get("statistic");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set statistic(value: string) {
    this.set("statistic", Value.fromString(value));
  }

  get veDelegateStatistic(): string {
    let value = this.get("veDelegateStatistic");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set veDelegateStatistic(value: string) {
    this.set("veDelegateStatistic", Value.fromString(value));
  }
}

export class RoundStatistic extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoundStatistic entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoundStatistic must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RoundStatistic", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RoundStatistic | null {
    return changetype<RoundStatistic | null>(
      store.get_in_block("RoundStatistic", id),
    );
  }

  static load(id: string): RoundStatistic | null {
    return changetype<RoundStatistic | null>(store.get("RoundStatistic", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get b3tr(): BigDecimal {
    let value = this.get("b3tr");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set b3tr(value: BigDecimal) {
    this.set("b3tr", Value.fromBigDecimal(value));
  }

  get b3trExact(): BigInt {
    let value = this.get("b3trExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set b3trExact(value: BigInt) {
    this.set("b3trExact", Value.fromBigInt(value));
  }

  get vot3(): BigDecimal {
    let value = this.get("vot3");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set vot3(value: BigDecimal) {
    this.set("vot3", Value.fromBigDecimal(value));
  }

  get vot3Exact(): BigInt {
    let value = this.get("vot3Exact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set vot3Exact(value: BigInt) {
    this.set("vot3Exact", Value.fromBigInt(value));
  }

  get voters(): BigInt {
    let value = this.get("voters");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voters(value: BigInt) {
    this.set("voters", Value.fromBigInt(value));
  }

  get votesCast(): BigDecimal {
    let value = this.get("votesCast");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set votesCast(value: BigDecimal) {
    this.set("votesCast", Value.fromBigDecimal(value));
  }

  get votesCastExact(): BigInt {
    let value = this.get("votesCastExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set votesCastExact(value: BigInt) {
    this.set("votesCastExact", Value.fromBigInt(value));
  }

  get weight(): BigDecimal {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set weight(value: BigDecimal) {
    this.set("weight", Value.fromBigDecimal(value));
  }

  get weightExact(): BigInt {
    let value = this.get("weightExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weightExact(value: BigInt) {
    this.set("weightExact", Value.fromBigInt(value));
  }

  get totalRewardsClaimed(): BigDecimal {
    let value = this.get("totalRewardsClaimed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set totalRewardsClaimed(value: BigDecimal) {
    this.set("totalRewardsClaimed", Value.fromBigDecimal(value));
  }

  get totalRewardsClaimedExact(): BigInt {
    let value = this.get("totalRewardsClaimedExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalRewardsClaimedExact(value: BigInt) {
    this.set("totalRewardsClaimedExact", Value.fromBigInt(value));
  }
}

export class App extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save App entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type App must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("App", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): App | null {
    return changetype<App | null>(store.get_in_block("App", id.toHexString()));
  }

  static load(id: Bytes): App | null {
    return changetype<App | null>(store.get("App", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get name(): string | null {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set name(value: string | null) {
    if (!value) {
      this.unset("name");
    } else {
      this.set("name", Value.fromString(<string>value));
    }
  }

  get metadata(): string | null {
    let value = this.get("metadata");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set metadata(value: string | null) {
    if (!value) {
      this.unset("metadata");
    } else {
      this.set("metadata", Value.fromString(<string>value));
    }
  }

  get metadataURI(): string | null {
    let value = this.get("metadataURI");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set metadataURI(value: string | null) {
    if (!value) {
      this.unset("metadataURI");
    } else {
      this.set("metadataURI", Value.fromString(<string>value));
    }
  }

  get votingEligibility(): boolean {
    let value = this.get("votingEligibility");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set votingEligibility(value: boolean) {
    this.set("votingEligibility", Value.fromBoolean(value));
  }

  get poolBalance(): BigDecimal {
    let value = this.get("poolBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set poolBalance(value: BigDecimal) {
    this.set("poolBalance", Value.fromBigDecimal(value));
  }

  get poolBalanceExact(): BigInt {
    let value = this.get("poolBalanceExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolBalanceExact(value: BigInt) {
    this.set("poolBalanceExact", Value.fromBigInt(value));
  }

  get poolDeposits(): BigDecimal {
    let value = this.get("poolDeposits");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set poolDeposits(value: BigDecimal) {
    this.set("poolDeposits", Value.fromBigDecimal(value));
  }

  get poolDepositsExact(): BigInt {
    let value = this.get("poolDepositsExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolDepositsExact(value: BigInt) {
    this.set("poolDepositsExact", Value.fromBigInt(value));
  }

  get poolDepositEvent(): RewardPoolDepositLoader {
    return new RewardPoolDepositLoader(
      "App",
      this.get("id")!.toBytes().toHexString(),
      "poolDepositEvent",
    );
  }

  get poolWithdrawals(): BigDecimal {
    let value = this.get("poolWithdrawals");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set poolWithdrawals(value: BigDecimal) {
    this.set("poolWithdrawals", Value.fromBigDecimal(value));
  }

  get poolWithdrawalsExact(): BigInt {
    let value = this.get("poolWithdrawalsExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolWithdrawalsExact(value: BigInt) {
    this.set("poolWithdrawalsExact", Value.fromBigInt(value));
  }

  get poolWithdrawEvent(): RewardPoolWithdrawLoader {
    return new RewardPoolWithdrawLoader(
      "App",
      this.get("id")!.toBytes().toHexString(),
      "poolWithdrawEvent",
    );
  }

  get poolDistributions(): BigDecimal {
    let value = this.get("poolDistributions");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set poolDistributions(value: BigDecimal) {
    this.set("poolDistributions", Value.fromBigDecimal(value));
  }

  get poolDistributionsExact(): BigInt {
    let value = this.get("poolDistributionsExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolDistributionsExact(value: BigInt) {
    this.set("poolDistributionsExact", Value.fromBigInt(value));
  }

  get poolDistributionEvent(): RewardPoolDistributionLoader {
    return new RewardPoolDistributionLoader(
      "App",
      this.get("id")!.toBytes().toHexString(),
      "poolDistributionEvent",
    );
  }

  get sustainabilityProof(): SustainabilityProofLoader {
    return new SustainabilityProofLoader(
      "App",
      this.get("id")!.toBytes().toHexString(),
      "sustainabilityProof",
    );
  }

  get createdAtBlockNumber(): BigInt {
    let value = this.get("createdAtBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdAtBlockNumber(value: BigInt) {
    this.set("createdAtBlockNumber", Value.fromBigInt(value));
  }

  get updatedAtBlockNumber(): BigInt {
    let value = this.get("updatedAtBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set updatedAtBlockNumber(value: BigInt) {
    this.set("updatedAtBlockNumber", Value.fromBigInt(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}

export class AppMetadata extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AppMetadata entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AppMetadata must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AppMetadata", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AppMetadata | null {
    return changetype<AppMetadata | null>(
      store.get_in_block("AppMetadata", id),
    );
  }

  static load(id: string): AppMetadata | null {
    return changetype<AppMetadata | null>(store.get("AppMetadata", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get title(): string | null {
    let value = this.get("title");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set title(value: string | null) {
    if (!value) {
      this.unset("title");
    } else {
      this.set("title", Value.fromString(<string>value));
    }
  }

  get description(): string | null {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set description(value: string | null) {
    if (!value) {
      this.unset("description");
    } else {
      this.set("description", Value.fromString(<string>value));
    }
  }

  get externalUrl(): string | null {
    let value = this.get("externalUrl");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set externalUrl(value: string | null) {
    if (!value) {
      this.unset("externalUrl");
    } else {
      this.set("externalUrl", Value.fromString(<string>value));
    }
  }

  get logoUrl(): string | null {
    let value = this.get("logoUrl");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set logoUrl(value: string | null) {
    if (!value) {
      this.unset("logoUrl");
    } else {
      this.set("logoUrl", Value.fromString(<string>value));
    }
  }

  get bannerUrl(): string | null {
    let value = this.get("bannerUrl");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set bannerUrl(value: string | null) {
    if (!value) {
      this.unset("bannerUrl");
    } else {
      this.set("bannerUrl", Value.fromString(<string>value));
    }
  }
}

export class AllocationResult extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AllocationResult entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AllocationResult must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AllocationResult", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AllocationResult | null {
    return changetype<AllocationResult | null>(
      store.get_in_block("AllocationResult", id),
    );
  }

  static load(id: string): AllocationResult | null {
    return changetype<AllocationResult | null>(
      store.get("AllocationResult", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get round(): string {
    let value = this.get("round");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set round(value: string) {
    this.set("round", Value.fromString(value));
  }

  get app(): Bytes {
    let value = this.get("app");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set app(value: Bytes) {
    this.set("app", Value.fromBytes(value));
  }

  get voters(): BigInt {
    let value = this.get("voters");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voters(value: BigInt) {
    this.set("voters", Value.fromBigInt(value));
  }

  get weight(): BigDecimal {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set weight(value: BigDecimal) {
    this.set("weight", Value.fromBigDecimal(value));
  }

  get weightExact(): BigInt {
    let value = this.get("weightExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weightExact(value: BigInt) {
    this.set("weightExact", Value.fromBigInt(value));
  }

  get votesCast(): BigDecimal {
    let value = this.get("votesCast");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set votesCast(value: BigDecimal) {
    this.set("votesCast", Value.fromBigDecimal(value));
  }

  get votesCastExact(): BigInt {
    let value = this.get("votesCastExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set votesCastExact(value: BigInt) {
    this.set("votesCastExact", Value.fromBigInt(value));
  }
}

export class AllocationVote extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AllocationVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AllocationVote must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AllocationVote", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AllocationVote | null {
    return changetype<AllocationVote | null>(
      store.get_in_block("AllocationVote", id),
    );
  }

  static load(id: string): AllocationVote | null {
    return changetype<AllocationVote | null>(store.get("AllocationVote", id));
  }

  get id(): i64 {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI64();
    }
  }

  set id(value: i64) {
    this.set("id", Value.fromI64(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get round(): string {
    let value = this.get("round");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set round(value: string) {
    this.set("round", Value.fromString(value));
  }

  get app(): Bytes {
    let value = this.get("app");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set app(value: Bytes) {
    this.set("app", Value.fromBytes(value));
  }

  get weight(): BigDecimal {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set weight(value: BigDecimal) {
    this.set("weight", Value.fromBigDecimal(value));
  }

  get weightExact(): BigInt {
    let value = this.get("weightExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weightExact(value: BigInt) {
    this.set("weightExact", Value.fromBigInt(value));
  }

  get qfWeight(): BigDecimal {
    let value = this.get("qfWeight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set qfWeight(value: BigDecimal) {
    this.set("qfWeight", Value.fromBigDecimal(value));
  }

  get qfWeightExact(): BigInt {
    let value = this.get("qfWeightExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set qfWeightExact(value: BigInt) {
    this.set("qfWeightExact", Value.fromBigInt(value));
  }

  get timestamp(): i64 {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toTimestamp();
    }
  }

  set timestamp(value: i64) {
    this.set("timestamp", Value.fromTimestamp(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }
}

export class RewardClaimed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RewardClaimed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RewardClaimed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RewardClaimed", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RewardClaimed | null {
    return changetype<RewardClaimed | null>(
      store.get_in_block("RewardClaimed", id),
    );
  }

  static load(id: string): RewardClaimed | null {
    return changetype<RewardClaimed | null>(store.get("RewardClaimed", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get round(): string {
    let value = this.get("round");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set round(value: string) {
    this.set("round", Value.fromString(value));
  }

  get reward(): BigDecimal {
    let value = this.get("reward");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set reward(value: BigDecimal) {
    this.set("reward", Value.fromBigDecimal(value));
  }

  get rewardExact(): BigInt {
    let value = this.get("rewardExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set rewardExact(value: BigInt) {
    this.set("rewardExact", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }
}

export class VeDelegateAccount extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VeDelegateAccount entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type VeDelegateAccount must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VeDelegateAccount", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): VeDelegateAccount | null {
    return changetype<VeDelegateAccount | null>(
      store.get_in_block("VeDelegateAccount", id.toHexString()),
    );
  }

  static load(id: Bytes): VeDelegateAccount | null {
    return changetype<VeDelegateAccount | null>(
      store.get("VeDelegateAccount", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }
}

export class Account extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Account must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Account", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Account | null {
    return changetype<Account | null>(
      store.get_in_block("Account", id.toHexString()),
    );
  }

  static load(id: Bytes): Account | null {
    return changetype<Account | null>(store.get("Account", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asVeDelegate(): ERC721TokenLoader {
    return new ERC721TokenLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "asVeDelegate",
    );
  }

  get asERC721(): Bytes | null {
    let value = this.get("asERC721");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asERC721(value: Bytes | null) {
    if (!value) {
      this.unset("asERC721");
    } else {
      this.set("asERC721", Value.fromBytes(<Bytes>value));
    }
  }

  get AllocationVotes(): AllocationVoteLoader {
    return new AllocationVoteLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "AllocationVotes",
    );
  }

  get ProposalVotes(): VoteReceiptLoader {
    return new VoteReceiptLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ProposalVotes",
    );
  }

  get B3TRRewards(): RewardClaimedLoader {
    return new RewardClaimedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "B3TRRewards",
    );
  }

  get ERC721tokens(): ERC721TokenLoader {
    return new ERC721TokenLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC721tokens",
    );
  }

  get ERC721operatorOwner(): ERC721OperatorLoader {
    return new ERC721OperatorLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC721operatorOwner",
    );
  }

  get ERC721operatorOperator(): ERC721OperatorLoader {
    return new ERC721OperatorLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC721operatorOperator",
    );
  }

  get ERC721transferFromEvent(): ERC721TransferLoader {
    return new ERC721TransferLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC721transferFromEvent",
    );
  }

  get ERC721transferToEvent(): ERC721TransferLoader {
    return new ERC721TransferLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC721transferToEvent",
    );
  }

  get asERC20(): Bytes | null {
    let value = this.get("asERC20");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asERC20(value: Bytes | null) {
    if (!value) {
      this.unset("asERC20");
    } else {
      this.set("asERC20", Value.fromBytes(<Bytes>value));
    }
  }

  get ERC20balances(): ERC20BalanceLoader {
    return new ERC20BalanceLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC20balances",
    );
  }

  get ERC20approvalsOwner(): ERC20ApprovalLoader {
    return new ERC20ApprovalLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC20approvalsOwner",
    );
  }

  get ERC20approvalsSpender(): ERC20ApprovalLoader {
    return new ERC20ApprovalLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC20approvalsSpender",
    );
  }

  get ERC20transferFromEvent(): ERC20TransferLoader {
    return new ERC20TransferLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC20transferFromEvent",
    );
  }

  get ERC20transferToEvent(): ERC20TransferLoader {
    return new ERC20TransferLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "ERC20transferToEvent",
    );
  }

  get asVoting(): Bytes | null {
    let value = this.get("asVoting");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asVoting(value: Bytes | null) {
    if (!value) {
      this.unset("asVoting");
    } else {
      this.set("asVoting", Value.fromBytes(<Bytes>value));
    }
  }

  get delegationFrom(): VoteDelegationLoader {
    return new VoteDelegationLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegationFrom",
    );
  }

  get delegationTo(): VoteDelegationLoader {
    return new VoteDelegationLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegationTo",
    );
  }

  get voteWeigth(): VoteWeightLoader {
    return new VoteWeightLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "voteWeigth",
    );
  }

  get delegateChangedEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedEvent",
    );
  }

  get delegateChangedFromEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedFromEvent",
    );
  }

  get delegateChangedToEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedToEvent",
    );
  }

  get delegateVotesChangedEvent(): DelegateVotesChangedLoader {
    return new DelegateVotesChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateVotesChangedEvent",
    );
  }

  get asTimelock(): Bytes | null {
    let value = this.get("asTimelock");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asTimelock(value: Bytes | null) {
    if (!value) {
      this.unset("asTimelock");
    } else {
      this.set("asTimelock", Value.fromBytes(<Bytes>value));
    }
  }

  get timelockedCalls(): TimelockCallLoader {
    return new TimelockCallLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "timelockedCalls",
    );
  }

  get asGovernor(): Bytes | null {
    let value = this.get("asGovernor");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asGovernor(value: Bytes | null) {
    if (!value) {
      this.unset("asGovernor");
    } else {
      this.set("asGovernor", Value.fromBytes(<Bytes>value));
    }
  }

  get proposed(): ProposalLoader {
    return new ProposalLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "proposed",
    );
  }

  get voted(): VoteReceiptLoader {
    return new VoteReceiptLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "voted",
    );
  }

  get proposedCalls(): ProposalCallLoader {
    return new ProposalCallLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "proposedCalls",
    );
  }
}

export class ERC721Contract extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC721Contract entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ERC721Contract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC721Contract", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ERC721Contract | null {
    return changetype<ERC721Contract | null>(
      store.get_in_block("ERC721Contract", id.toHexString()),
    );
  }

  static load(id: Bytes): ERC721Contract | null {
    return changetype<ERC721Contract | null>(
      store.get("ERC721Contract", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get supportsMetadata(): boolean {
    let value = this.get("supportsMetadata");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set supportsMetadata(value: boolean) {
    this.set("supportsMetadata", Value.fromBoolean(value));
  }

  get name(): string | null {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set name(value: string | null) {
    if (!value) {
      this.unset("name");
    } else {
      this.set("name", Value.fromString(<string>value));
    }
  }

  get symbol(): string | null {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set symbol(value: string | null) {
    if (!value) {
      this.unset("symbol");
    } else {
      this.set("symbol", Value.fromString(<string>value));
    }
  }

  get tokens(): ERC721TokenLoader {
    return new ERC721TokenLoader(
      "ERC721Contract",
      this.get("id")!.toBytes().toHexString(),
      "tokens",
    );
  }

  get operators(): ERC721OperatorLoader {
    return new ERC721OperatorLoader(
      "ERC721Contract",
      this.get("id")!.toBytes().toHexString(),
      "operators",
    );
  }

  get transfers(): ERC721TransferLoader {
    return new ERC721TransferLoader(
      "ERC721Contract",
      this.get("id")!.toBytes().toHexString(),
      "transfers",
    );
  }
}

export class ERC721Token extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC721Token entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ERC721Token must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC721Token", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ERC721Token | null {
    return changetype<ERC721Token | null>(
      store.get_in_block("ERC721Token", id),
    );
  }

  static load(id: string): ERC721Token | null {
    return changetype<ERC721Token | null>(store.get("ERC721Token", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get identifier(): BigInt {
    let value = this.get("identifier");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set identifier(value: BigInt) {
    this.set("identifier", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get approval(): Bytes {
    let value = this.get("approval");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set approval(value: Bytes) {
    this.set("approval", Value.fromBytes(value));
  }

  get uri(): string | null {
    let value = this.get("uri");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set uri(value: string | null) {
    if (!value) {
      this.unset("uri");
    } else {
      this.set("uri", Value.fromString(<string>value));
    }
  }

  get transfers(): ERC721TransferLoader {
    return new ERC721TransferLoader(
      "ERC721Token",
      this.get("id")!.toString(),
      "transfers",
    );
  }

  get poolAddress(): Bytes | null {
    let value = this.get("poolAddress");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set poolAddress(value: Bytes | null) {
    if (!value) {
      this.unset("poolAddress");
    } else {
      this.set("poolAddress", Value.fromBytes(<Bytes>value));
    }
  }
}

export class ERC721Operator extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC721Operator entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ERC721Operator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC721Operator", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ERC721Operator | null {
    return changetype<ERC721Operator | null>(
      store.get_in_block("ERC721Operator", id),
    );
  }

  static load(id: string): ERC721Operator | null {
    return changetype<ERC721Operator | null>(store.get("ERC721Operator", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get approved(): boolean {
    let value = this.get("approved");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set approved(value: boolean) {
    this.set("approved", Value.fromBoolean(value));
  }
}

export class ERC721Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC721Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ERC721Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC721Transfer", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ERC721Transfer | null {
    return changetype<ERC721Transfer | null>(
      store.get_in_block("ERC721Transfer", id),
    );
  }

  static load(id: string): ERC721Transfer | null {
    return changetype<ERC721Transfer | null>(store.get("ERC721Transfer", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class ERC20Contract extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC20Contract entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ERC20Contract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC20Contract", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ERC20Contract | null {
    return changetype<ERC20Contract | null>(
      store.get_in_block("ERC20Contract", id.toHexString()),
    );
  }

  static load(id: Bytes): ERC20Contract | null {
    return changetype<ERC20Contract | null>(
      store.get("ERC20Contract", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get name(): string | null {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set name(value: string | null) {
    if (!value) {
      this.unset("name");
    } else {
      this.set("name", Value.fromString(<string>value));
    }
  }

  get symbol(): string | null {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set symbol(value: string | null) {
    if (!value) {
      this.unset("symbol");
    } else {
      this.set("symbol", Value.fromString(<string>value));
    }
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get totalSupply(): string {
    let value = this.get("totalSupply");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set totalSupply(value: string) {
    this.set("totalSupply", Value.fromString(value));
  }

  get balances(): ERC20BalanceLoader {
    return new ERC20BalanceLoader(
      "ERC20Contract",
      this.get("id")!.toBytes().toHexString(),
      "balances",
    );
  }

  get approvals(): ERC20ApprovalLoader {
    return new ERC20ApprovalLoader(
      "ERC20Contract",
      this.get("id")!.toBytes().toHexString(),
      "approvals",
    );
  }

  get transfers(): ERC20TransferLoader {
    return new ERC20TransferLoader(
      "ERC20Contract",
      this.get("id")!.toBytes().toHexString(),
      "transfers",
    );
  }
}

export class ERC20Balance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC20Balance entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ERC20Balance must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC20Balance", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ERC20Balance | null {
    return changetype<ERC20Balance | null>(
      store.get_in_block("ERC20Balance", id),
    );
  }

  static load(id: string): ERC20Balance | null {
    return changetype<ERC20Balance | null>(store.get("ERC20Balance", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get account(): Bytes | null {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes | null) {
    if (!value) {
      this.unset("account");
    } else {
      this.set("account", Value.fromBytes(<Bytes>value));
    }
  }

  get value(): BigDecimal {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get valueExact(): BigInt {
    let value = this.get("valueExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set valueExact(value: BigInt) {
    this.set("valueExact", Value.fromBigInt(value));
  }

  get transferFromEvent(): ERC20TransferLoader {
    return new ERC20TransferLoader(
      "ERC20Balance",
      this.get("id")!.toString(),
      "transferFromEvent",
    );
  }

  get transferToEvent(): ERC20TransferLoader {
    return new ERC20TransferLoader(
      "ERC20Balance",
      this.get("id")!.toString(),
      "transferToEvent",
    );
  }
}

export class ERC20Approval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC20Approval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ERC20Approval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC20Approval", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ERC20Approval | null {
    return changetype<ERC20Approval | null>(
      store.get_in_block("ERC20Approval", id),
    );
  }

  static load(id: string): ERC20Approval | null {
    return changetype<ERC20Approval | null>(store.get("ERC20Approval", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigDecimal {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get valueExact(): BigInt {
    let value = this.get("valueExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set valueExact(value: BigInt) {
    this.set("valueExact", Value.fromBigInt(value));
  }
}

export class ERC20Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC20Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ERC20Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ERC20Transfer", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ERC20Transfer | null {
    return changetype<ERC20Transfer | null>(
      store.get_in_block("ERC20Transfer", id),
    );
  }

  static load(id: string): ERC20Transfer | null {
    return changetype<ERC20Transfer | null>(store.get("ERC20Transfer", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get from(): Bytes | null {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes | null) {
    if (!value) {
      this.unset("from");
    } else {
      this.set("from", Value.fromBytes(<Bytes>value));
    }
  }

  get fromBalance(): string | null {
    let value = this.get("fromBalance");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set fromBalance(value: string | null) {
    if (!value) {
      this.unset("fromBalance");
    } else {
      this.set("fromBalance", Value.fromString(<string>value));
    }
  }

  get to(): Bytes | null {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes | null) {
    if (!value) {
      this.unset("to");
    } else {
      this.set("to", Value.fromBytes(<Bytes>value));
    }
  }

  get toBalance(): string | null {
    let value = this.get("toBalance");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set toBalance(value: string | null) {
    if (!value) {
      this.unset("toBalance");
    } else {
      this.set("toBalance", Value.fromString(<string>value));
    }
  }

  get value(): BigDecimal {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get valueExact(): BigInt {
    let value = this.get("valueExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set valueExact(value: BigInt) {
    this.set("valueExact", Value.fromBigInt(value));
  }
}

export class VotingContract extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VotingContract entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type VotingContract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VotingContract", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): VotingContract | null {
    return changetype<VotingContract | null>(
      store.get_in_block("VotingContract", id.toHexString()),
    );
  }

  static load(id: Bytes): VotingContract | null {
    return changetype<VotingContract | null>(
      store.get("VotingContract", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get totalWeight(): string {
    let value = this.get("totalWeight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set totalWeight(value: string) {
    this.set("totalWeight", Value.fromString(value));
  }

  get weight(): VoteWeightLoader {
    return new VoteWeightLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "weight",
    );
  }

  get delegation(): VoteDelegationLoader {
    return new VoteDelegationLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "delegation",
    );
  }

  get delegateChangedEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedEvent",
    );
  }

  get delegateVotesChangedEvent(): DelegateVotesChangedLoader {
    return new DelegateVotesChangedLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "delegateVotesChangedEvent",
    );
  }
}

export class VoteDelegation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteDelegation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteDelegation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteDelegation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteDelegation | null {
    return changetype<VoteDelegation | null>(
      store.get_in_block("VoteDelegation", id),
    );
  }

  static load(id: string): VoteDelegation | null {
    return changetype<VoteDelegation | null>(store.get("VoteDelegation", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delegator(): Bytes {
    let value = this.get("delegator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegator(value: Bytes) {
    this.set("delegator", Value.fromBytes(value));
  }

  get delegatee(): Bytes {
    let value = this.get("delegatee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegatee(value: Bytes) {
    this.set("delegatee", Value.fromBytes(value));
  }

  get delegateChangedEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "VoteDelegation",
      this.get("id")!.toString(),
      "delegateChangedEvent",
    );
  }
}

export class VoteWeight extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteWeight entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteWeight must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteWeight", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteWeight | null {
    return changetype<VoteWeight | null>(store.get_in_block("VoteWeight", id));
  }

  static load(id: string): VoteWeight | null {
    return changetype<VoteWeight | null>(store.get("VoteWeight", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get account(): Bytes | null {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes | null) {
    if (!value) {
      this.unset("account");
    } else {
      this.set("account", Value.fromBytes(<Bytes>value));
    }
  }

  get value(): BigInt {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get delegateVotesChangedEvent(): DelegateVotesChangedLoader {
    return new DelegateVotesChangedLoader(
      "VoteWeight",
      this.get("id")!.toString(),
      "delegateVotesChangedEvent",
    );
  }
}

export class DelegateChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegateChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegateChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("DelegateChanged", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DelegateChanged | null {
    return changetype<DelegateChanged | null>(
      store.get_in_block("DelegateChanged", id),
    );
  }

  static load(id: string): DelegateChanged | null {
    return changetype<DelegateChanged | null>(store.get("DelegateChanged", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get delegation(): string | null {
    let value = this.get("delegation");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set delegation(value: string | null) {
    if (!value) {
      this.unset("delegation");
    } else {
      this.set("delegation", Value.fromString(<string>value));
    }
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delegator(): Bytes {
    let value = this.get("delegator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegator(value: Bytes) {
    this.set("delegator", Value.fromBytes(value));
  }

  get fromDelegate(): Bytes {
    let value = this.get("fromDelegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set fromDelegate(value: Bytes) {
    this.set("fromDelegate", Value.fromBytes(value));
  }

  get toDelegate(): Bytes {
    let value = this.get("toDelegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set toDelegate(value: Bytes) {
    this.set("toDelegate", Value.fromBytes(value));
  }
}

export class DelegateVotesChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegateVotesChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegateVotesChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("DelegateVotesChanged", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DelegateVotesChanged | null {
    return changetype<DelegateVotesChanged | null>(
      store.get_in_block("DelegateVotesChanged", id),
    );
  }

  static load(id: string): DelegateVotesChanged | null {
    return changetype<DelegateVotesChanged | null>(
      store.get("DelegateVotesChanged", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get voteWeight(): string | null {
    let value = this.get("voteWeight");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set voteWeight(value: string | null) {
    if (!value) {
      this.unset("voteWeight");
    } else {
      this.set("voteWeight", Value.fromString(<string>value));
    }
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delegate(): Bytes {
    let value = this.get("delegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegate(value: Bytes) {
    this.set("delegate", Value.fromBytes(value));
  }

  get oldValue(): BigInt {
    let value = this.get("oldValue");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set oldValue(value: BigInt) {
    this.set("oldValue", Value.fromBigInt(value));
  }

  get newValue(): BigInt {
    let value = this.get("newValue");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set newValue(value: BigInt) {
    this.set("newValue", Value.fromBigInt(value));
  }
}

export class Timelock extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Timelock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Timelock must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Timelock", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Timelock | null {
    return changetype<Timelock | null>(
      store.get_in_block("Timelock", id.toHexString()),
    );
  }

  static load(id: Bytes): Timelock | null {
    return changetype<Timelock | null>(store.get("Timelock", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get operations(): TimelockOperationLoader {
    return new TimelockOperationLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "operations",
    );
  }

  get scheduled(): TimelockOperationScheduledLoader {
    return new TimelockOperationScheduledLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "scheduled",
    );
  }

  get executed(): TimelockOperationExecutedLoader {
    return new TimelockOperationExecutedLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "executed",
    );
  }

  get cancelled(): TimelockOperationCancelledLoader {
    return new TimelockOperationCancelledLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "cancelled",
    );
  }

  get mindelaychange(): TimelockMinDelayChangeLoader {
    return new TimelockMinDelayChangeLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "mindelaychange",
    );
  }
}

export class TimelockOperation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TimelockOperation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperation | null {
    return changetype<TimelockOperation | null>(
      store.get_in_block("TimelockOperation", id),
    );
  }

  static load(id: string): TimelockOperation | null {
    return changetype<TimelockOperation | null>(
      store.get("TimelockOperation", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get status(): string {
    let value = this.get("status");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get predecessor(): string | null {
    let value = this.get("predecessor");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set predecessor(value: string | null) {
    if (!value) {
      this.unset("predecessor");
    } else {
      this.set("predecessor", Value.fromString(<string>value));
    }
  }

  get calls(): TimelockCallLoader {
    return new TimelockCallLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "calls",
    );
  }

  get scheduled(): TimelockOperationScheduledLoader {
    return new TimelockOperationScheduledLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "scheduled",
    );
  }

  get executed(): TimelockOperationExecutedLoader {
    return new TimelockOperationExecutedLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "executed",
    );
  }

  get cancelled(): TimelockOperationCancelledLoader {
    return new TimelockOperationCancelledLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "cancelled",
    );
  }
}

export class TimelockCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TimelockCall entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockCall must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockCall", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockCall | null {
    return changetype<TimelockCall | null>(
      store.get_in_block("TimelockCall", id),
    );
  }

  static load(id: string): TimelockCall | null {
    return changetype<TimelockCall | null>(store.get("TimelockCall", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get value(): BigDecimal {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get data(): Bytes {
    let value = this.get("data");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set data(value: Bytes) {
    this.set("data", Value.fromBytes(value));
  }

  get scheduled(): TimelockOperationScheduledLoader {
    return new TimelockOperationScheduledLoader(
      "TimelockCall",
      this.get("id")!.toString(),
      "scheduled",
    );
  }

  get executed(): TimelockOperationExecutedLoader {
    return new TimelockOperationExecutedLoader(
      "TimelockCall",
      this.get("id")!.toString(),
      "executed",
    );
  }
}

export class TimelockOperationScheduled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockOperationScheduled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperationScheduled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperationScheduled", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperationScheduled | null {
    return changetype<TimelockOperationScheduled | null>(
      store.get_in_block("TimelockOperationScheduled", id),
    );
  }

  static load(id: string): TimelockOperationScheduled | null {
    return changetype<TimelockOperationScheduled | null>(
      store.get("TimelockOperationScheduled", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get call(): string {
    let value = this.get("call");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set call(value: string) {
    this.set("call", Value.fromString(value));
  }
}

export class TimelockOperationExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockOperationExecuted entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperationExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperationExecuted", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperationExecuted | null {
    return changetype<TimelockOperationExecuted | null>(
      store.get_in_block("TimelockOperationExecuted", id),
    );
  }

  static load(id: string): TimelockOperationExecuted | null {
    return changetype<TimelockOperationExecuted | null>(
      store.get("TimelockOperationExecuted", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get call(): string {
    let value = this.get("call");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set call(value: string) {
    this.set("call", Value.fromString(value));
  }
}

export class TimelockOperationCancelled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockOperationCancelled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperationCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperationCancelled", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperationCancelled | null {
    return changetype<TimelockOperationCancelled | null>(
      store.get_in_block("TimelockOperationCancelled", id),
    );
  }

  static load(id: string): TimelockOperationCancelled | null {
    return changetype<TimelockOperationCancelled | null>(
      store.get("TimelockOperationCancelled", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }
}

export class TimelockMinDelayChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockMinDelayChange entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockMinDelayChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockMinDelayChange", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockMinDelayChange | null {
    return changetype<TimelockMinDelayChange | null>(
      store.get_in_block("TimelockMinDelayChange", id),
    );
  }

  static load(id: string): TimelockMinDelayChange | null {
    return changetype<TimelockMinDelayChange | null>(
      store.get("TimelockMinDelayChange", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }
}

export class Governor extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Governor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Governor must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Governor", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Governor | null {
    return changetype<Governor | null>(
      store.get_in_block("Governor", id.toHexString()),
    );
  }

  static load(id: Bytes): Governor | null {
    return changetype<Governor | null>(store.get("Governor", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get mode(): string | null {
    let value = this.get("mode");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set mode(value: string | null) {
    if (!value) {
      this.unset("mode");
    } else {
      this.set("mode", Value.fromString(<string>value));
    }
  }

  get proposals(): ProposalLoader {
    return new ProposalLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposals",
    );
  }

  get proposalCreated(): ProposalCreatedLoader {
    return new ProposalCreatedLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalCreated",
    );
  }

  get proposalQueued(): ProposalQueuedLoader {
    return new ProposalQueuedLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalQueued",
    );
  }

  get proposalExecuted(): ProposalExecutedLoader {
    return new ProposalExecutedLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalExecuted",
    );
  }

  get proposalCanceled(): ProposalCanceledLoader {
    return new ProposalCanceledLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalCanceled",
    );
  }

  get votecast(): VoteCastLoader {
    return new VoteCastLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "votecast",
    );
  }
}

export class Proposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Proposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Proposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Proposal", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Proposal | null {
    return changetype<Proposal | null>(store.get_in_block("Proposal", id));
  }

  static load(id: string): Proposal | null {
    return changetype<Proposal | null>(store.get("Proposal", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposalId(): BigInt {
    let value = this.get("proposalId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set proposalId(value: BigInt) {
    this.set("proposalId", Value.fromBigInt(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get round(): string | null {
    let value = this.get("round");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set round(value: string | null) {
    if (!value) {
      this.unset("round");
    } else {
      this.set("round", Value.fromString(<string>value));
    }
  }

  get descriptionUri(): string | null {
    let value = this.get("descriptionUri");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set descriptionUri(value: string | null) {
    if (!value) {
      this.unset("descriptionUri");
    } else {
      this.set("descriptionUri", Value.fromString(<string>value));
    }
  }

  get description(): string | null {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set description(value: string | null) {
    if (!value) {
      this.unset("description");
    } else {
      this.set("description", Value.fromString(<string>value));
    }
  }

  get canceled(): boolean {
    let value = this.get("canceled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set canceled(value: boolean) {
    this.set("canceled", Value.fromBoolean(value));
  }

  get queued(): boolean {
    let value = this.get("queued");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set queued(value: boolean) {
    this.set("queued", Value.fromBoolean(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get calls(): ProposalCallLoader {
    return new ProposalCallLoader(
      "Proposal",
      this.get("id")!.toString(),
      "calls",
    );
  }

  get supports(): ProposalSupportLoader {
    return new ProposalSupportLoader(
      "Proposal",
      this.get("id")!.toString(),
      "supports",
    );
  }

  get receipts(): VoteReceiptLoader {
    return new VoteReceiptLoader(
      "Proposal",
      this.get("id")!.toString(),
      "receipts",
    );
  }

  get proposalCreated(): ProposalCreatedLoader {
    return new ProposalCreatedLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalCreated",
    );
  }

  get proposalQueued(): ProposalQueuedLoader {
    return new ProposalQueuedLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalQueued",
    );
  }

  get proposalExecuted(): ProposalExecutedLoader {
    return new ProposalExecutedLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalExecuted",
    );
  }

  get proposalCanceled(): ProposalCanceledLoader {
    return new ProposalCanceledLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalCanceled",
    );
  }

  get votecast(): VoteCastLoader {
    return new VoteCastLoader(
      "Proposal",
      this.get("id")!.toString(),
      "votecast",
    );
  }

  get deposits(): ProposalDepositLoader {
    return new ProposalDepositLoader(
      "Proposal",
      this.get("id")!.toString(),
      "deposits",
    );
  }

  get depositCount(): BigInt {
    let value = this.get("depositCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set depositCount(value: BigInt) {
    this.set("depositCount", Value.fromBigInt(value));
  }

  get depositAmount(): BigInt {
    let value = this.get("depositAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set depositAmount(value: BigInt) {
    this.set("depositAmount", Value.fromBigInt(value));
  }

  get thresholdAmount(): BigInt {
    let value = this.get("thresholdAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set thresholdAmount(value: BigInt) {
    this.set("thresholdAmount", Value.fromBigInt(value));
  }

  get voterCount(): BigInt {
    let value = this.get("voterCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voterCount(value: BigInt) {
    this.set("voterCount", Value.fromBigInt(value));
  }

  get votesCast(): BigInt {
    let value = this.get("votesCast");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set votesCast(value: BigInt) {
    this.set("votesCast", Value.fromBigInt(value));
  }

  get weightCast(): BigInt {
    let value = this.get("weightCast");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weightCast(value: BigInt) {
    this.set("weightCast", Value.fromBigInt(value));
  }
}

export class ProposalMetadata extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalMetadata entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalMetadata must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalMetadata", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalMetadata | null {
    return changetype<ProposalMetadata | null>(
      store.get_in_block("ProposalMetadata", id),
    );
  }

  static load(id: string): ProposalMetadata | null {
    return changetype<ProposalMetadata | null>(
      store.get("ProposalMetadata", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get title(): string | null {
    let value = this.get("title");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set title(value: string | null) {
    if (!value) {
      this.unset("title");
    } else {
      this.set("title", Value.fromString(<string>value));
    }
  }

  get shortDescription(): string | null {
    let value = this.get("shortDescription");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set shortDescription(value: string | null) {
    if (!value) {
      this.unset("shortDescription");
    } else {
      this.set("shortDescription", Value.fromString(<string>value));
    }
  }

  get markdownDescription(): string | null {
    let value = this.get("markdownDescription");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set markdownDescription(value: string | null) {
    if (!value) {
      this.unset("markdownDescription");
    } else {
      this.set("markdownDescription", Value.fromString(<string>value));
    }
  }
}

export class ProposalCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCall entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCall must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalCall", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalCall | null {
    return changetype<ProposalCall | null>(
      store.get_in_block("ProposalCall", id),
    );
  }

  static load(id: string): ProposalCall | null {
    return changetype<ProposalCall | null>(store.get("ProposalCall", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get index(): i32 {
    let value = this.get("index");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set index(value: i32) {
    this.set("index", Value.fromI32(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get value(): BigDecimal {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get signature(): string {
    let value = this.get("signature");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set signature(value: string) {
    this.set("signature", Value.fromString(value));
  }

  get calldata(): Bytes {
    let value = this.get("calldata");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set calldata(value: Bytes) {
    this.set("calldata", Value.fromBytes(value));
  }
}

export class ProposalSupport extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalSupport entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalSupport must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalSupport", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalSupport | null {
    return changetype<ProposalSupport | null>(
      store.get_in_block("ProposalSupport", id),
    );
  }

  static load(id: string): ProposalSupport | null {
    return changetype<ProposalSupport | null>(store.get("ProposalSupport", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get support(): i32 {
    let value = this.get("support");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set support(value: i32) {
    this.set("support", Value.fromI32(value));
  }

  get voter(): BigInt {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voter(value: BigInt) {
    this.set("voter", Value.fromBigInt(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get power(): BigInt {
    let value = this.get("power");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set power(value: BigInt) {
    this.set("power", Value.fromBigInt(value));
  }

  get votes(): VoteReceiptLoader {
    return new VoteReceiptLoader(
      "ProposalSupport",
      this.get("id")!.toString(),
      "votes",
    );
  }
}

export class VoteReceipt extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteReceipt entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteReceipt must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteReceipt", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteReceipt | null {
    return changetype<VoteReceipt | null>(
      store.get_in_block("VoteReceipt", id),
    );
  }

  static load(id: string): VoteReceipt | null {
    return changetype<VoteReceipt | null>(store.get("VoteReceipt", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get support(): string {
    let value = this.get("support");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set support(value: string) {
    this.set("support", Value.fromString(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get power(): BigInt {
    let value = this.get("power");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set power(value: BigInt) {
    this.set("power", Value.fromBigInt(value));
  }

  get reason(): string {
    let value = this.get("reason");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set reason(value: string) {
    this.set("reason", Value.fromString(value));
  }

  get params(): Bytes | null {
    let value = this.get("params");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set params(value: Bytes | null) {
    if (!value) {
      this.unset("params");
    } else {
      this.set("params", Value.fromBytes(<Bytes>value));
    }
  }
}

export class ProposalCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalCreated | null {
    return changetype<ProposalCreated | null>(
      store.get_in_block("ProposalCreated", id),
    );
  }

  static load(id: string): ProposalCreated | null {
    return changetype<ProposalCreated | null>(store.get("ProposalCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }
}

export class ProposalQueued extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalQueued entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalQueued must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalQueued", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalQueued | null {
    return changetype<ProposalQueued | null>(
      store.get_in_block("ProposalQueued", id),
    );
  }

  static load(id: string): ProposalQueued | null {
    return changetype<ProposalQueued | null>(store.get("ProposalQueued", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get eta(): BigInt {
    let value = this.get("eta");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set eta(value: BigInt) {
    this.set("eta", Value.fromBigInt(value));
  }
}

export class ProposalExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalExecuted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalExecuted", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalExecuted | null {
    return changetype<ProposalExecuted | null>(
      store.get_in_block("ProposalExecuted", id),
    );
  }

  static load(id: string): ProposalExecuted | null {
    return changetype<ProposalExecuted | null>(
      store.get("ProposalExecuted", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }
}

export class ProposalCanceled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCanceled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCanceled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalCanceled", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalCanceled | null {
    return changetype<ProposalCanceled | null>(
      store.get_in_block("ProposalCanceled", id),
    );
  }

  static load(id: string): ProposalCanceled | null {
    return changetype<ProposalCanceled | null>(
      store.get("ProposalCanceled", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }
}

export class VoteCast extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteCast entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteCast must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteCast", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteCast | null {
    return changetype<VoteCast | null>(store.get_in_block("VoteCast", id));
  }

  static load(id: string): VoteCast | null {
    return changetype<VoteCast | null>(store.get("VoteCast", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get support(): string {
    let value = this.get("support");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set support(value: string) {
    this.set("support", Value.fromString(value));
  }

  get receipt(): string {
    let value = this.get("receipt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set receipt(value: string) {
    this.set("receipt", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }
}

export class ProposalDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalDeposit", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalDeposit | null {
    return changetype<ProposalDeposit | null>(
      store.get_in_block("ProposalDeposit", id),
    );
  }

  static load(id: string): ProposalDeposit | null {
    return changetype<ProposalDeposit | null>(store.get("ProposalDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get depositor(): Bytes {
    let value = this.get("depositor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set depositor(value: Bytes) {
    this.set("depositor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class Transaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Transaction", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Transaction | null {
    return changetype<Transaction | null>(
      store.get_in_block("Transaction", id),
    );
  }

  static load(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get("Transaction", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class RewardPoolDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RewardPoolDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RewardPoolDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RewardPoolDeposit", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RewardPoolDeposit | null {
    return changetype<RewardPoolDeposit | null>(
      store.get_in_block("RewardPoolDeposit", id),
    );
  }

  static load(id: string): RewardPoolDeposit | null {
    return changetype<RewardPoolDeposit | null>(
      store.get("RewardPoolDeposit", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get app(): Bytes {
    let value = this.get("app");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set app(value: Bytes) {
    this.set("app", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get amountExact(): BigInt {
    let value = this.get("amountExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountExact(value: BigInt) {
    this.set("amountExact", Value.fromBigInt(value));
  }

  get depositor(): Bytes {
    let value = this.get("depositor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set depositor(value: Bytes) {
    this.set("depositor", Value.fromBytes(value));
  }
}

export class RewardPoolWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RewardPoolWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RewardPoolWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RewardPoolWithdraw", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RewardPoolWithdraw | null {
    return changetype<RewardPoolWithdraw | null>(
      store.get_in_block("RewardPoolWithdraw", id),
    );
  }

  static load(id: string): RewardPoolWithdraw | null {
    return changetype<RewardPoolWithdraw | null>(
      store.get("RewardPoolWithdraw", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get app(): Bytes {
    let value = this.get("app");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set app(value: Bytes) {
    this.set("app", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get amountExact(): BigInt {
    let value = this.get("amountExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountExact(value: BigInt) {
    this.set("amountExact", Value.fromBigInt(value));
  }

  get by(): Bytes {
    let value = this.get("by");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set by(value: Bytes) {
    this.set("by", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get reason(): string {
    let value = this.get("reason");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set reason(value: string) {
    this.set("reason", Value.fromString(value));
  }
}

export class RewardPoolDistribution extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save RewardPoolDistribution entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RewardPoolDistribution must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RewardPoolDistribution", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RewardPoolDistribution | null {
    return changetype<RewardPoolDistribution | null>(
      store.get_in_block("RewardPoolDistribution", id),
    );
  }

  static load(id: string): RewardPoolDistribution | null {
    return changetype<RewardPoolDistribution | null>(
      store.get("RewardPoolDistribution", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get app(): Bytes {
    let value = this.get("app");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set app(value: Bytes) {
    this.set("app", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get amountExact(): BigInt {
    let value = this.get("amountExact");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountExact(value: BigInt) {
    this.set("amountExact", Value.fromBigInt(value));
  }

  get by(): Bytes {
    let value = this.get("by");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set by(value: Bytes) {
    this.set("by", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get proof(): string | null {
    let value = this.get("proof");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set proof(value: string | null) {
    if (!value) {
      this.unset("proof");
    } else {
      this.set("proof", Value.fromString(<string>value));
    }
  }
}

export class AppSustainability extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AppSustainability entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AppSustainability must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AppSustainability", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AppSustainability | null {
    return changetype<AppSustainability | null>(
      store.get_in_block("AppSustainability", id),
    );
  }

  static load(id: string): AppSustainability | null {
    return changetype<AppSustainability | null>(
      store.get("AppSustainability", id),
    );
  }

  get id(): i64 {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI64();
    }
  }

  set id(value: i64) {
    this.set("id", Value.fromI64(value));
  }

  get app(): Bytes {
    let value = this.get("app");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set app(value: Bytes) {
    this.set("app", Value.fromBytes(value));
  }

  get timestamp(): i64 {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toTimestamp();
    }
  }

  set timestamp(value: i64) {
    this.set("timestamp", Value.fromTimestamp(value));
  }

  get carbon(): BigInt {
    let value = this.get("carbon");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set carbon(value: BigInt) {
    this.set("carbon", Value.fromBigInt(value));
  }

  get water(): BigInt {
    let value = this.get("water");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set water(value: BigInt) {
    this.set("water", Value.fromBigInt(value));
  }

  get energy(): BigInt {
    let value = this.get("energy");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set energy(value: BigInt) {
    this.set("energy", Value.fromBigInt(value));
  }

  get wasteMass(): BigInt {
    let value = this.get("wasteMass");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set wasteMass(value: BigInt) {
    this.set("wasteMass", Value.fromBigInt(value));
  }

  get wasteItems(): BigInt {
    let value = this.get("wasteItems");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set wasteItems(value: BigInt) {
    this.set("wasteItems", Value.fromBigInt(value));
  }

  get people(): BigInt {
    let value = this.get("people");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set people(value: BigInt) {
    this.set("people", Value.fromBigInt(value));
  }

  get biodiversity(): BigInt {
    let value = this.get("biodiversity");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set biodiversity(value: BigInt) {
    this.set("biodiversity", Value.fromBigInt(value));
  }
}

export class SustainabilityProof extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SustainabilityProof entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SustainabilityProof must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("SustainabilityProof", id.toString(), this);
    }
  }

  static loadInBlock(id: string): SustainabilityProof | null {
    return changetype<SustainabilityProof | null>(
      store.get_in_block("SustainabilityProof", id),
    );
  }

  static load(id: string): SustainabilityProof | null {
    return changetype<SustainabilityProof | null>(
      store.get("SustainabilityProof", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): i64 {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toTimestamp();
    }
  }

  set timestamp(value: i64) {
    this.set("timestamp", Value.fromTimestamp(value));
  }

  get app(): Bytes {
    let value = this.get("app");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set app(value: Bytes) {
    this.set("app", Value.fromBytes(value));
  }

  get proofType(): string | null {
    let value = this.get("proofType");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set proofType(value: string | null) {
    if (!value) {
      this.unset("proofType");
    } else {
      this.set("proofType", Value.fromString(<string>value));
    }
  }

  get proofData(): string | null {
    let value = this.get("proofData");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set proofData(value: string | null) {
    if (!value) {
      this.unset("proofData");
    } else {
      this.set("proofData", Value.fromString(<string>value));
    }
  }

  get description(): string | null {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set description(value: string | null) {
    if (!value) {
      this.unset("description");
    } else {
      this.set("description", Value.fromString(<string>value));
    }
  }

  get additionalInfo(): string | null {
    let value = this.get("additionalInfo");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set additionalInfo(value: string | null) {
    if (!value) {
      this.unset("additionalInfo");
    } else {
      this.set("additionalInfo", Value.fromString(<string>value));
    }
  }

  get carbon(): BigInt {
    let value = this.get("carbon");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set carbon(value: BigInt) {
    this.set("carbon", Value.fromBigInt(value));
  }

  get water(): BigInt {
    let value = this.get("water");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set water(value: BigInt) {
    this.set("water", Value.fromBigInt(value));
  }

  get energy(): BigInt {
    let value = this.get("energy");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set energy(value: BigInt) {
    this.set("energy", Value.fromBigInt(value));
  }

  get wasteMass(): BigInt {
    let value = this.get("wasteMass");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set wasteMass(value: BigInt) {
    this.set("wasteMass", Value.fromBigInt(value));
  }

  get wasteItems(): BigInt {
    let value = this.get("wasteItems");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set wasteItems(value: BigInt) {
    this.set("wasteItems", Value.fromBigInt(value));
  }

  get people(): BigInt {
    let value = this.get("people");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set people(value: BigInt) {
    this.set("people", Value.fromBigInt(value));
  }

  get biodiversity(): BigInt {
    let value = this.get("biodiversity");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set biodiversity(value: BigInt) {
    this.set("biodiversity", Value.fromBigInt(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }
}

export class ProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Proposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Proposal[]>(value);
  }
}

export class RewardPoolDepositLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RewardPoolDeposit[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RewardPoolDeposit[]>(value);
  }
}

export class RewardPoolWithdrawLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RewardPoolWithdraw[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RewardPoolWithdraw[]>(value);
  }
}

export class RewardPoolDistributionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RewardPoolDistribution[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RewardPoolDistribution[]>(value);
  }
}

export class SustainabilityProofLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): SustainabilityProof[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<SustainabilityProof[]>(value);
  }
}

export class ERC721TokenLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ERC721Token[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ERC721Token[]>(value);
  }
}

export class AllocationVoteLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AllocationVote[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AllocationVote[]>(value);
  }
}

export class VoteReceiptLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteReceipt[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteReceipt[]>(value);
  }
}

export class RewardClaimedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RewardClaimed[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RewardClaimed[]>(value);
  }
}

export class ERC721OperatorLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ERC721Operator[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ERC721Operator[]>(value);
  }
}

export class ERC721TransferLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ERC721Transfer[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ERC721Transfer[]>(value);
  }
}

export class ERC20BalanceLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ERC20Balance[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ERC20Balance[]>(value);
  }
}

export class ERC20ApprovalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ERC20Approval[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ERC20Approval[]>(value);
  }
}

export class ERC20TransferLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ERC20Transfer[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ERC20Transfer[]>(value);
  }
}

export class VoteDelegationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteDelegation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteDelegation[]>(value);
  }
}

export class VoteWeightLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteWeight[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteWeight[]>(value);
  }
}

export class DelegateChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DelegateChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DelegateChanged[]>(value);
  }
}

export class DelegateVotesChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DelegateVotesChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DelegateVotesChanged[]>(value);
  }
}

export class TimelockCallLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockCall[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockCall[]>(value);
  }
}

export class ProposalCallLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalCall[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalCall[]>(value);
  }
}

export class TimelockOperationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperation[]>(value);
  }
}

export class TimelockOperationScheduledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperationScheduled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperationScheduled[]>(value);
  }
}

export class TimelockOperationExecutedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperationExecuted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperationExecuted[]>(value);
  }
}

export class TimelockOperationCancelledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperationCancelled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperationCancelled[]>(value);
  }
}

export class TimelockMinDelayChangeLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockMinDelayChange[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockMinDelayChange[]>(value);
  }
}

export class ProposalCreatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalCreated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalCreated[]>(value);
  }
}

export class ProposalQueuedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalQueued[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalQueued[]>(value);
  }
}

export class ProposalExecutedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalExecuted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalExecuted[]>(value);
  }
}

export class ProposalCanceledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalCanceled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalCanceled[]>(value);
  }
}

export class VoteCastLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteCast[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteCast[]>(value);
  }
}

export class ProposalSupportLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalSupport[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalSupport[]>(value);
  }
}

export class ProposalDepositLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalDeposit[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalDeposit[]>(value);
  }
}
